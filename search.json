[{"title":"husky + eslint + lint-staged 配置方法","date":"2021-06-20T10:17:22.000Z","url":"/2021/06/20/husky_eslint_lint_staged/","tags":[["husky+eslint+lint-staged","/tags/husky-eslint-lint-staged/"]],"categories":[["husky+eslint+lint-staged","/categories/husky-eslint-lint-staged/"]],"content":"husky + eslint + lint-staged husky: git的一个钩子，用来帮助运行一些指令在特定的git运行阶段，比如提交前. eslint: 用特定的配置来对代码进行风格检查以此来保证代码的一致性和低bugs. husky: husky-doceslint: eslint-doc####husky的使用 ##1 . install husky npm install -D husky 先将husky添加到项目的开发依赖中， ##2 . inject git hooks npm set-script prepare &quot;husky install&quot; npm set-script 是version 7.x才有的指令，所有如果提示没有找到set-script，可以手动在package.json添加prepare脚本. 这个prepare是npm4.0.0引入的新life cycle script，(prepare: 在执行npm的指令时，会根据情况，提前或之后运行预设指令，具体可查看 ).npm低于7.x, 手动添加prepare脚本: husky install会创建一个.husky目录并指定该目录为git hooks所在目录。这里有两个不同的特殊情况，如果这个.husky需要放到其他文件目录中，比如.config目录中，可以在install后，追加路径 如果你的package.json和你的.git目录不在一个目录level，那么执行husky install之前，要先跳转到.git目录，也就是说这个指令必须是在你.git存在的目录下运行. 另外所有的钩子，都必须要跳转到package.json所在目录执行， ##3 . 添加钩子 钩子都是添加到husky的目录下 npx husky add .husky/pre-commit &quot;npm run test&quot;. 运行后在.husky目录下会添加也给pre-commit的shell脚本， 这个pre-commit就是会在git提交之前执行 npm run test. 如果想要测试，可以在shell脚本最后添加 exit 1， 正常配置后，所有的commit都会失败，如果希望在某系特定情况下阻止提交，脚本就必须以非零的退出代码推出. 可能其他文档会用: 这个是husky v4的写法，而在husky v6中，所有的指令都在脚本中执行，无需定义在package.json. ##4 . eslint的使用 安装eslint npm install eslint --save-dev 安装后，如果已有配置文件，那么配置就基本完成. 如果没有配置文件，那么可以通过 npx eslint --init 来初始化文件 在这之后，目录下会生成一个.eslintrc.js或yml或json文件，该文件就是eslint的配置文件. 在extends中会有一句eslint: recommanded，在eslint 1.0 version 之后所有的rules都会关闭，通用的一些规则会通过eslint: recommanded打开， 如果不想要那些通用的规则，则可删除此行，可如果想要查看具体有哪些规则打开，可通过 打开的规则查看. 如果想要直接使用eslint校验某个文件的代码，则可通过npm eslint files.js如果想要直接使用eslint校验一个目录下的所有文件，则可通过现在package.json中添加 在执行 npm run lint ##5 . husky + eslint + lint-staged 结合 lint-staged: 如果每次都lint所有的文件会运行极慢，那么如果每次只lint要提交的文件，那么速度就可以极快。 lint-staged可以让我们运行一些指令在git add之后的文件上。 安装 npm install lint-staged 安装后需要配置lint-staged的配置文件，配置主要有两种方式，第一种是在package.json文件中配置 第二种方法是配置一个.lintstagedrc文件.lintstagedrc 配置文件中主要是配置filter，比如对于git add之后的js和ts的暂存文件进行lint，那么配置方法为.lintstagedrc package.json 中括号是对于以js和ts结尾的文件执行的指令，eslint –fix是通过刚刚eslint的配置对文件进行校验，如果有可以进行修复的，则进行修复，如果不能则抛出错误."},{"title":"graphQL基础3","date":"2021-06-17T10:17:22.000Z","url":"/2021/06/17/graphQL%E5%9F%BA%E7%A1%803/","tags":[["graphQL","/tags/graphQL/"]],"categories":[["graphQL-basic","/categories/graphQL-basic/"]],"content":"1. graphQL基础31 构造函数类型 (server-side)(Constructing Types) 之前的写schema的方式是通过buildSchema的方式。比如 另一种定义schema的方式是通过GraphQLObjectType. 这种方式的好处是在于维护更加容易，buildSchema由于都是字符串，如果出了问题很不容易被发现。通过GraphQLObjectType定义的话，是比较容易发现问题。 1.1 Query查询定义query查询和定义类型不太一样，name是query，fileds里面要给返回类型，参数和返回值等等 最后一步就是构成schema "},{"title":"graphQL基础","date":"2021-05-25T11:36:40.000Z","url":"/2021/05/25/graphQL%E5%9F%BA%E7%A1%80/","tags":[["graphQL","/tags/graphQL/"]],"categories":[["graphQL-basic","/categories/graphQL-basic/"]],"content":"graphQL 基础查询 3. graphQL基础31 查询 (server-side)Query 是一个关键字，代表一个操作类型 (operation type)。 所有查询的方法都必须在这个字段下， 返回值如果不是graphql的自带标量类型，那么就需要使用type来定义。 1.1 自带标量类型graphql自带标量类型为: Int, Float, String, Boolean, ID(unique). 那么返回值可以直接填这几个类型。 1.2 复杂/自定义类型如果为自定义类型，需要使用type关键字定义 当接收到query请求后，会根据操作名称，也就是查询方法来寻找对应的处理函数。 2. 处理函数处理方法就是普通的js函数，只不过命名，参数这些地方会有些要求。比如我们上面有一个getCompanyName的Query,返回值类型是company，那么我们的处理函数就可以是 3. 后端服务器搭建 express + express-graphql + graphql express: 后端服务器 express-graphql: graphql http server (用来解析， 比如收到一个query，如何根据你的schema来找到对应的函数，然后交给函数处理。 graphql是构建schema 3.1 包导入 buildSchema用来来构建schema,也就是刚刚写的那些请求,比如 type query{…}, 3.2 buildSchame 那么我们就定义好了，两个查询方法，一个getCompanyName,一个getCompanyInfo.这两个方法的返回值分别为String和Company复杂类型 3.3 处理函数 graphqlHTTP这三个参数，schema是接口定义，rootValue是处理函数入口，graphiql是测试界面，如果我们通过location:4000/graphql，就可以访问到测试页面 4 测试在测试页面, 可以用shorthand syntax来查询 "},{"title":"graphQL基础2","date":"2021-05-25T11:36:40.000Z","url":"/2021/05/25/graphQL%E5%9F%BA%E7%A1%802/","tags":[["graphQL","/tags/graphQL/"]],"categories":[["graphQL-basic","/categories/graphQL-basic/"]],"content":"graphQL 参数传递基础 4. 参数传递1.服务端1.1 返回值为列表[类型]数组，例如[Int]代表整数数组 1.2. !(叹号) 参数不能为空numDice是必须传参，null是不行的， numSides是可以不传入的。返回类型是number类型的数组 1.3 处理函数参数接收参数正常来说是会传入一个args的对象，这个对象是可以在接受的时候就进行解构的 1.4 嵌套参数传递我们在查询的时候，子属性也是可以有参数的. 上面这个例子就是我们在对用户信息进行查询时，他的返回值，我们是可以进行参数传递的。正常来说，我们的参数都要在通过传参传入，但是GraphQL可以允许你在选择返回值的时候进行传参。这个时候处理函数就要变成 1.4 综合例子 2 查询端"}]